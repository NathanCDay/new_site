---
title: An inputMap for your Shiny app
author: Nate Day
date: '2019-05-05'
categories:
  - data viz
tags:
  - leaflet
  - shiny
---

## inputMap()

Spatial vizualizations and especially interactive ones, are great tools to communicate physical location data. Building interactive maps in R is realivelty straight forward via the `leaflet` library. And constructing data apps is also pretty simple with the `shiny` package. This post combines these two, to make a map input widget for Shiny, that uses click events to filter a data set.

## 3 steps

1) Make the map

I'm using R's library `sf` to handle the spatial data here but there are alternatives. `leaflet` maps will work with a [variaty of other formats](https://rstudio.github.io/leaflet/map_widget.html), including `matrix`/`data.frame`, `sp` objects, and `map` objects.

```{r make_map}
library(sf)

nc <- st_read(system.file("shape/nc.shp", package="sf"))

library(leaflet)

map <- leaflet(nc,
               options = leafletOptions(
                 zoomControl = FALSE,
                 dragging = FALSE,
                 minZoom = 6,
                 maxZoom = 6)
               ) %>%
  addPolygons(
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )

map
```

The `leafletOptions()` arguments are important because I don't want the input map moving. If you want this "style", you will have to adjust the `minZoom`/`maxZoom` values, depending on the size of the map your select. The `highlightOptions()` and `label` help make the map better as a selection tool.

2) Add map to your shiny app

Build a `leaflet` map output somewhere in your `server`. Remember `nc` must be available, but should probably be read in outside of the `server`.

```{r add_to_app, eval = FALSE}
output$inputMap <- renderLeaflet({
  leaflet(nc,
           options = leafletOptions(
             zoomControl = FALSE,
             dragging = FALSE,
             minZoom = 6,
             maxZoom = 6)
               ) %>%
  addPolygons(
    layerID = ~NAME, # note this is new
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )
})
```

Note the `layerID` argument is essential for next step. I reccomend making this the same variable you want to filter the data set with.

Now somewhere in `ui` make the container to hold the map.

```{r}
leafletOutput("inputMap", height = 200)
```

3) Listen for clicks

Set up observer in `server`. To access `leaflet` events there is a special syntax `input$MAPID_OBJECT_EVENT`. Because of this pattern you should not use "_"s in your `MAPID`.

```{r listener, eval = F}
  observe({
    click <- input$inputMap_shape_click
    if (is.null(click)) return()
    
    output$filteredResults <- renderDataTable({
      nc %>% filter(NAME == click$id)
    })
  })
```

That's it. Now you have a map you can use as an input widget.

## Working app

<script src="https://gist.github.com/nathancday/18f570dd89e71f4f88b11ef79cdd94ca.js"></script>

