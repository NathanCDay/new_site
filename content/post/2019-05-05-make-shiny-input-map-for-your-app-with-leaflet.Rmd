---
title: An inputMap for your Shiny app
author: Nate Day
date: '2019-05-05'
categories:
  - data viz
tags:
  - leaflet
  - shiny
---

## inputMap()

Spatial vizualizations and especially interactive ones, are great tools to communicate physical location data. Building interactive maps in R is realivelty straight forward via the `leaflet` library. And constructing data apps is also pretty simple with the `shiny` package.

This post combines these, to make a map input widget for Shiny. In this example I'll build a map that listens for click event and filters a data set based on the selected region.

### 1: Make the map

I'm using R's library `sf` to handle the spatial data here but there are alternatives. `leaflet` maps will work with a [variaty of other formats](https://rstudio.github.io/leaflet/map_widget.html), including `matrix`/`data.frame`, `sp` objects, and `map` objects.

```{r make_map}
library(sf)

nc <- st_read(system.file("shape/nc.shp", package="sf"))

library(leaflet)

map <- leaflet(nc,
               options = leafletOptions(
                 zoomControl = FALSE,
                 dragging = FALSE,
                 minZoom = 6,
                 maxZoom = 6)
               ) %>%
  addPolygons(
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )

widgetframe::frameWidget(map, height = '400')
```

The `leafletOptions()` arguments here are important because I don't want the input map moving. If you want this "style", you will have to adjust the `minZoom`/`maxZoom` values, depending on the size of the map your select. The `highlightOptions()` and `label` args make the map better as a selection tool, IMO.

### 2: Add map to app

Using the standard `leaflet` patterns, we add a `renderLeaflet()`, to build the map somewhere in your `server`. Remember the `nc` data must be available, but should probably be read in outside of the `server`.

```{r add_to_app, eval = FALSE}
output$inputMap <- renderLeaflet({
  leaflet(nc,
           options = leafletOptions(
             zoomControl = FALSE,
             dragging = FALSE,
             minZoom = 6,
             maxZoom = 6)
               ) %>%
  addPolygons(
    layerID = ~NAME, # note this is new
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )
})
```

Note the `layerID` argument, it is essential for next step. I reccomend making this the same variable you want to filter the data set with.

Now somewhere in `ui` use `leafletOutput()` to make the container to hold the map. This would be located with the other input widgets, maybe in a sidebar or fluid row.

```{r, eval = F}
leafletOutput("inputMap", height = 200)
```

3) Listen for clicks

Set up observer in `server`. To access `leaflet` events there is a special syntax `input$MAPID_OBJECT_EVENT`. Because of this, you shouldn't use "_"s in your `MAPID`.

```{r listener, eval = F}
  observe({
    click <- input$inputMap_shape_click
    if (is.null(click)) return()
    
    output$filteredResults <- renderDataTable({
      nc %>% filter(NAME == click$id)
    })
  })
```

That's it. Now you have a map you can use as an input widget.

## Working app
<iframe>
<script src="https://gist.github.com/nathancday/18f570dd89e71f4f88b11ef79cdd94ca.js"></script>
</iframe>
