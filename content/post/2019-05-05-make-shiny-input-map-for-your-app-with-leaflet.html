---
title: An inputMap for your Shiny app
author: Nate Day
date: '2019-05-05'
categories:
  - data viz
tags:
  - leaflet
  - shiny
---

<script src="/rmarkdown-libs/htmlwidgets/htmlwidgets.js"></script>
<script src="/rmarkdown-libs/pymjs/pym.v1.js"></script>
<script src="/rmarkdown-libs/widgetframe-binding/widgetframe.js"></script>


<div id="inputmap" class="section level2">
<h2>inputMap()</h2>
<p>Spatial vizualizations and especially interactive ones, are great tools to communicate physical location data. Building interactive maps in R is realivelty straight forward via the <code>leaflet</code> library. And constructing data apps is also pretty simple with the <code>shiny</code> package.</p>
<p>This post combines these, to make a map input widget for Shiny. In this example I’ll build a map that listens for click event and filters a data set based on the selected region.</p>
<div id="make-the-map" class="section level3">
<h3>1: Make the map</h3>
<p>I’m using R’s library <code>sf</code> to handle the spatial data here but there are alternatives. <code>leaflet</code> maps will work with a <a href="https://rstudio.github.io/leaflet/map_widget.html">variaty of other formats</a>, including <code>matrix</code>/<code>data.frame</code>, <code>sp</code> objects, and <code>map</code> objects.</p>
<pre class="r"><code>library(sf)</code></pre>
<pre><code>## Linking to GEOS 3.7.1, GDAL 2.4.0, PROJ 5.2.0</code></pre>
<pre class="r"><code>nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;))</code></pre>
<pre><code>## Reading layer `nc&#39; from data source `/Users/nathanday/Library/R/3.5/library/sf/shape/nc.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 100 features and 14 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
## epsg (SRID):    4267
## proj4string:    +proj=longlat +datum=NAD27 +no_defs</code></pre>
<pre class="r"><code>library(leaflet)

map &lt;- leaflet(nc,
               options = leafletOptions(
                 zoomControl = FALSE,
                 dragging = FALSE,
                 minZoom = 6,
                 maxZoom = 6)
               ) %&gt;%
  addPolygons(
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )</code></pre>
<pre><code>## Warning: sf layer has inconsistent datum (+proj=longlat +datum=NAD27 +no_defs).
## Need &#39;+proj=longlat +datum=WGS84&#39;</code></pre>
<pre class="r"><code>widgetframe::frameWidget(map, height = &#39;400&#39;)</code></pre>
<div id="htmlwidget-1" style="width:100%;height:400px;" class="widgetframe html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"url":"/post/2019-05-05-make-shiny-input-map-for-your-app-with-leaflet_files/figure-html//widgets/widget_make_map.html","options":{"xdomain":"*","allowfullscreen":false,"lazyload":false}},"evals":[],"jsHooks":[]}</script>
<p>The <code>leafletOptions()</code> arguments here are important because I don’t want the input map moving. If you want this “style”, you will have to adjust the <code>minZoom</code>/<code>maxZoom</code> values, depending on the size of the map your select. The <code>highlightOptions()</code> and <code>label</code> args make the map better as a selection tool, IMO.</p>
</div>
<div id="add-map-to-app" class="section level3">
<h3>2: Add map to app</h3>
<p>Using the standard <code>leaflet</code> patterns, we add a <code>renderLeaflet()</code>, to build the map somewhere in your <code>server</code>. Remember the <code>nc</code> data must be available, but should probably be read in outside of the <code>server</code>.</p>
<pre class="r"><code>output$inputMap &lt;- renderLeaflet({
  leaflet(nc,
           options = leafletOptions(
             zoomControl = FALSE,
             dragging = FALSE,
             minZoom = 6,
             maxZoom = 6)
               ) %&gt;%
  addPolygons(
    layerID = ~NAME, # note this is new
    label = ~NAME,
    highlight = highlightOptions(
      fillOpacity = 1,
      bringToFront = TRUE)
  )
})</code></pre>
<p>Note the <code>layerID</code> argument, it is essential for next step. I reccomend making this the same variable you want to filter the data set with.</p>
<p>Now somewhere in <code>ui</code> use <code>leafletOutput()</code> to make the container to hold the map. This would be located with the other input widgets, maybe in a sidebar or fluid row.</p>
<pre class="r"><code>leafletOutput(&quot;inputMap&quot;, height = 200)</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Listen for clicks</li>
</ol>
<p>Set up observer in <code>server</code>. To access <code>leaflet</code> events there is a special syntax <code>input$MAPID_OBJECT_EVENT</code>. Because of this, you shouldn’t use "_"s in your <code>MAPID</code>.</p>
<pre class="r"><code>  observe({
    click &lt;- input$inputMap_shape_click
    if (is.null(click)) return()
    
    output$filteredResults &lt;- renderDataTable({
      nc %&gt;% filter(NAME == click$id)
    })
  })</code></pre>
<p>That’s it. Now you have a map you can use as an input widget.</p>
</div>
</div>
<div id="working-app" class="section level2">
<h2>Working app</h2>
<iframe>
<script src="https://gist.github.com/nathancday/18f570dd89e71f4f88b11ef79cdd94ca.js"></script>
</iframe>
</div>
